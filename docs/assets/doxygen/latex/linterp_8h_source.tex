\hypertarget{linterp_8h_source}{}\doxysection{linterp.\+h}
\label{linterp_8h_source}\index{/Users/pawel/projects/epic/NEW2/epic/include/algorithms/interpolation/linterp/linterp.h@{/Users/pawel/projects/epic/NEW2/epic/include/algorithms/interpolation/linterp/linterp.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 }
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 Ronaldo Carpio}}
\DoxyCodeLine{4 \textcolor{comment}{//                                     }}
\DoxyCodeLine{5 \textcolor{comment}{// Permission to use, copy, modify, distribute and sell this software}}
\DoxyCodeLine{6 \textcolor{comment}{// and its documentation for any purpose is hereby granted without fee,}}
\DoxyCodeLine{7 \textcolor{comment}{// provided that the above copyright notice appear in all copies and   }}
\DoxyCodeLine{8 \textcolor{comment}{// that both that copyright notice and this permission notice appear}}
\DoxyCodeLine{9 \textcolor{comment}{// in supporting documentation.  The authors make no representations}}
\DoxyCodeLine{10 \textcolor{comment}{// about the suitability of this software for any purpose.          }}
\DoxyCodeLine{11 \textcolor{comment}{// It is provided "{}as is"{} without express or implied warranty.}}
\DoxyCodeLine{12 \textcolor{comment}{//               }}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{comment}{/*}}
\DoxyCodeLine{15 \textcolor{comment}{This is a C++ header-\/only library for N-\/dimensional linear interpolation on a rectangular grid. Implements two methods:}}
\DoxyCodeLine{16 \textcolor{comment}{* Multilinear: Interpolate using the N-\/dimensional hypercube containing the point. Interpolation step is O(2\string^N) }}
\DoxyCodeLine{17 \textcolor{comment}{* Simplicial: Interpolate using the N-\/dimensional simplex containing the point. Interpolation step is O(N log N), but less accurate.}}
\DoxyCodeLine{18 \textcolor{comment}{Requires boost/multi\_array library.}}
\DoxyCodeLine{19 \textcolor{comment}{}}
\DoxyCodeLine{20 \textcolor{comment}{For a description of the algorithms, see:}}
\DoxyCodeLine{21 \textcolor{comment}{* Weiser \& Zarantonello (1988), "{}A Note on Piecewise Linear and Multilinear Table Interpolation in Many Dimensions"{}, \_Mathematics of Computation\_ 50 (181), p. 189-\/196}}
\DoxyCodeLine{22 \textcolor{comment}{* Davies (1996), "{}Multidimensional Triangulation and Interpolation for Reinforcement Learning"{}, \_Proceedings of Neural Information Processing Systems 1996\_}}
\DoxyCodeLine{23 \textcolor{comment}{*/}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{preprocessor}{\#ifndef \_linterp\_h}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#define \_linterp\_h}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <assert.h>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <math.h>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <stdarg.h>}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include <float.h>}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include <cstdarg>}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#include <array>}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{37 }
\DoxyCodeLine{38 \textcolor{preprocessor}{\#include <boost/multi\_array.hpp>}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#include <boost/numeric/ublas/matrix.hpp>}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#include <boost/numeric/ublas/matrix\_proxy.hpp>}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#include <boost/numeric/ublas/storage.hpp>}}
\DoxyCodeLine{42 }
\DoxyCodeLine{43 \textcolor{keyword}{using }std::vector;}
\DoxyCodeLine{44 \textcolor{keyword}{using }std::array;}
\DoxyCodeLine{45 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} uint;}
\DoxyCodeLine{46 \textcolor{keyword}{typedef} vector<int> iVec;}
\DoxyCodeLine{47 \textcolor{keyword}{typedef} vector<double> dVec;}
\DoxyCodeLine{48 }
\DoxyCodeLine{49 }
\DoxyCodeLine{50 \textcolor{comment}{// TODO:}}
\DoxyCodeLine{51 \textcolor{comment}{//  -\/ specify behavior past grid boundaries.}}
\DoxyCodeLine{52 \textcolor{comment}{//    1) clamp}}
\DoxyCodeLine{53 \textcolor{comment}{//    2) return a pre-\/determined value (e.g. NaN)}}
\DoxyCodeLine{54 }
\DoxyCodeLine{55 \textcolor{comment}{// compile-\/time params:}}
\DoxyCodeLine{56 \textcolor{comment}{//   1) number of dimensions}}
\DoxyCodeLine{57 \textcolor{comment}{//   2) scalar type T}}
\DoxyCodeLine{58 \textcolor{comment}{//   3) copy data or not (default: false). The grids will always be copied}}
\DoxyCodeLine{59 \textcolor{comment}{//   4) ref count class (default: none)}}
\DoxyCodeLine{60 \textcolor{comment}{//   5) continuous or not}}
\DoxyCodeLine{61 }
\DoxyCodeLine{62 \textcolor{comment}{// run-\/time constructor params:}}
\DoxyCodeLine{63 \textcolor{comment}{//   1) f}}
\DoxyCodeLine{64 \textcolor{comment}{//   2) grids}}
\DoxyCodeLine{65 \textcolor{comment}{//   3) behavior outside grid: default=clamp}}
\DoxyCodeLine{66 \textcolor{comment}{//   4) value to return outside grid, defaut=nan}}
\DoxyCodeLine{67 }
\DoxyCodeLine{68 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_empty_class}{EmptyClass}} \{\};}
\DoxyCodeLine{69 }
\DoxyCodeLine{70 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{class} T, \textcolor{keywordtype}{bool} CopyData = true, \textcolor{keywordtype}{bool} Continuous = true, \textcolor{keyword}{class} ArrayRefCountT = EmptyClass, \textcolor{keyword}{class} Gr\textcolor{keywordtype}{id}RefCountT = EmptyClass>}
\DoxyCodeLine{71 \textcolor{keyword}{class }\mbox{\hyperlink{class_n_d_interpolator}{NDInterpolator}} \{}
\DoxyCodeLine{72 \textcolor{keyword}{public}:}
\DoxyCodeLine{73   \textcolor{keyword}{typedef} T value\_type;}
\DoxyCodeLine{74   \textcolor{keyword}{typedef} ArrayRefCountT array\_ref\_count\_type;}
\DoxyCodeLine{75   \textcolor{keyword}{typedef} GridRefCountT grid\_ref\_count\_type;}
\DoxyCodeLine{76   }
\DoxyCodeLine{77   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} m\_N = N;}
\DoxyCodeLine{78   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} m\_bCopyData = CopyData;}
\DoxyCodeLine{79   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} m\_bContinuous = Continuous;}
\DoxyCodeLine{80   }
\DoxyCodeLine{81   \textcolor{keyword}{typedef} boost::numeric::ublas::array\_adaptor<T> grid\_type;}
\DoxyCodeLine{82   \textcolor{keyword}{typedef} boost::const\_multi\_array\_ref<T, N> array\_type; }
\DoxyCodeLine{83   \textcolor{keyword}{typedef} std::unique\_ptr<array\_type> array\_type\_ptr;}
\DoxyCodeLine{84   }
\DoxyCodeLine{85   array\_type\_ptr m\_pF;}
\DoxyCodeLine{86   ArrayRefCountT m\_ref\_F;                   \textcolor{comment}{// reference count for m\_pF}}
\DoxyCodeLine{87   vector<T> m\_F\_copy;                       \textcolor{comment}{// if CopyData == true, this holds the copy of F}}
\DoxyCodeLine{88      }
\DoxyCodeLine{89   vector<grid\_type> m\_grid\_list;    }
\DoxyCodeLine{90   vector<GridRefCountT> m\_grid\_ref\_list;    \textcolor{comment}{// reference counts for grids  }}
\DoxyCodeLine{91   vector<vector<T> > m\_grid\_copy\_list;      \textcolor{comment}{// if CopyData == true, this holds the copies of the grids}}
\DoxyCodeLine{92   }
\DoxyCodeLine{93   \textcolor{comment}{// constructors assume that [f\_begin, f\_end) is a contiguous array in C-\/order  }}
\DoxyCodeLine{94   \textcolor{comment}{// non ref-\/counted constructor.}}
\DoxyCodeLine{95   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2, \textcolor{keyword}{class} IterT3>  }
\DoxyCodeLine{96   \mbox{\hyperlink{class_n_d_interpolator}{NDInterpolator}}(IterT1 grids\_begin, IterT2 grids\_len\_begin, IterT3 f\_begin, IterT3 f\_end) \{}
\DoxyCodeLine{97     init(grids\_begin, grids\_len\_begin, f\_begin, f\_end);  }
\DoxyCodeLine{98   \}}
\DoxyCodeLine{99   }
\DoxyCodeLine{100   \textcolor{comment}{// ref-\/counted constructor}}
\DoxyCodeLine{101   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2, \textcolor{keyword}{class} IterT3, \textcolor{keyword}{class} RefCountIterT>}
\DoxyCodeLine{102   \mbox{\hyperlink{class_n_d_interpolator}{NDInterpolator}}(IterT1 grids\_begin, IterT2 grids\_len\_begin, IterT3 f\_begin, IterT3 f\_end, ArrayRefCountT \&refF, RefCountIterT grid\_refs\_begin) \{}
\DoxyCodeLine{103     init\_refcount(grids\_begin, grids\_len\_begin, f\_begin, f\_end, refF, grid\_refs\_begin);}
\DoxyCodeLine{104   \} }
\DoxyCodeLine{105   }
\DoxyCodeLine{106   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2, \textcolor{keyword}{class} IterT3>                                                       }
\DoxyCodeLine{107   \textcolor{keywordtype}{void} init(IterT1 grids\_begin, IterT2 grids\_len\_begin, IterT3 f\_begin, IterT3 f\_end) \{    }
\DoxyCodeLine{108     set\_grids(grids\_begin, grids\_len\_begin, m\_bCopyData);}
\DoxyCodeLine{109     set\_f\_array(f\_begin, f\_end, m\_bCopyData);}
\DoxyCodeLine{110   \}  }
\DoxyCodeLine{111   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2, \textcolor{keyword}{class} IterT3, \textcolor{keyword}{class} RefCountIterT>}
\DoxyCodeLine{112   \textcolor{keywordtype}{void} init\_refcount(IterT1 grids\_begin, IterT2 grids\_len\_begin, IterT3 f\_begin, IterT3 f\_end, ArrayRefCountT \&refF, RefCountIterT grid\_refs\_begin) \{       }
\DoxyCodeLine{113     set\_grids(grids\_begin, grids\_len\_begin, m\_bCopyData);}
\DoxyCodeLine{114     set\_grids\_refcount(grid\_refs\_begin, grid\_refs\_begin + N);}
\DoxyCodeLine{115     set\_f\_array(f\_begin, f\_end, m\_bCopyData);}
\DoxyCodeLine{116     set\_f\_refcount(refF);}
\DoxyCodeLine{117   \} }
\DoxyCodeLine{118 }
\DoxyCodeLine{119   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2>  }
\DoxyCodeLine{120   \textcolor{keywordtype}{void} set\_grids(IterT1 grids\_begin, IterT2 grids\_len\_begin, \textcolor{keywordtype}{bool} bCopy) \{}
\DoxyCodeLine{121     m\_grid\_list.clear();}
\DoxyCodeLine{122     m\_grid\_ref\_list.clear();}
\DoxyCodeLine{123     m\_grid\_copy\_list.clear();}
\DoxyCodeLine{124     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<N; i++) \{}
\DoxyCodeLine{125       \textcolor{keywordtype}{int} gridLength = grids\_len\_begin[i];}
\DoxyCodeLine{126       \textcolor{keywordflow}{if} (bCopy == \textcolor{keyword}{false}) \{     }
\DoxyCodeLine{127         T \textcolor{keyword}{const} *grid\_ptr = \&(*grids\_begin[i]);}
\DoxyCodeLine{128         m\_grid\_list.push\_back(grid\_type(gridLength, (T*) grid\_ptr ));                   \textcolor{comment}{// use the given pointer}}
\DoxyCodeLine{129       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{130         m\_grid\_copy\_list.push\_back( vector<T>(grids\_begin[i], grids\_begin[i] + grids\_len\_begin[i]) );   \textcolor{comment}{// make our own copy of the grid}}
\DoxyCodeLine{131         T *begin = \&(m\_grid\_copy\_list[i][0]);}
\DoxyCodeLine{132         m\_grid\_list.push\_back(grid\_type(gridLength, begin));                            \textcolor{comment}{// use our copy}}
\DoxyCodeLine{133       \}}
\DoxyCodeLine{134     \}}
\DoxyCodeLine{135   \}    }
\DoxyCodeLine{136   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} RefCountIterT>  }
\DoxyCodeLine{137   \textcolor{keywordtype}{void} set\_grids\_refcount(RefCountIterT refs\_begin, RefCountIterT refs\_end) \{}
\DoxyCodeLine{138     assert(refs\_end -\/ refs\_begin == N); }
\DoxyCodeLine{139     m\_grid\_ref\_list.assign(refs\_begin, refs\_begin + N);}
\DoxyCodeLine{140   \} }
\DoxyCodeLine{141   }
\DoxyCodeLine{142   \textcolor{comment}{// assumes that [f\_begin, f\_end) is a contiguous array in C-\/order  }}
\DoxyCodeLine{143   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT>  }
\DoxyCodeLine{144   \textcolor{keywordtype}{void} set\_f\_array(IterT f\_begin, IterT f\_end, \textcolor{keywordtype}{bool} bCopy) \{}
\DoxyCodeLine{145     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nGridPoints = 1;}
\DoxyCodeLine{146     array<int,N> sizes;}
\DoxyCodeLine{147     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<m\_grid\_list.size(); i++) \{}
\DoxyCodeLine{148       sizes[i] = m\_grid\_list[i].size();}
\DoxyCodeLine{149       nGridPoints *= sizes[i];}
\DoxyCodeLine{150     \}}
\DoxyCodeLine{151 }
\DoxyCodeLine{152     \textcolor{keywordtype}{int} f\_len = f\_end -\/ f\_begin;}
\DoxyCodeLine{153     \textcolor{keywordflow}{if} ( (m\_bContinuous \&\& f\_len != nGridPoints) || (!m\_bContinuous \&\& f\_len != 2 * nGridPoints) ) \{}
\DoxyCodeLine{154       \textcolor{keywordflow}{throw} std::invalid\_argument(\textcolor{stringliteral}{"{}f has wrong size"{}});}
\DoxyCodeLine{155     \}}
\DoxyCodeLine{156     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<m\_grid\_list.size(); i++) \{}
\DoxyCodeLine{157       \textcolor{keywordflow}{if} (!m\_bContinuous) \{ sizes[i] *= 2; \}      }
\DoxyCodeLine{158     \}}
\DoxyCodeLine{159 }
\DoxyCodeLine{160     m\_F\_copy.clear();}
\DoxyCodeLine{161     \textcolor{keywordflow}{if} (bCopy == \textcolor{keyword}{false}) \{}
\DoxyCodeLine{162       m\_pF.reset(\textcolor{keyword}{new} array\_type(f\_begin, sizes));}
\DoxyCodeLine{163     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{164       m\_F\_copy = vector<T>(f\_begin, f\_end);}
\DoxyCodeLine{165       m\_pF.reset(\textcolor{keyword}{new} array\_type(\&m\_F\_copy[0], sizes));}
\DoxyCodeLine{166     \}}
\DoxyCodeLine{167   \}  }
\DoxyCodeLine{168   \textcolor{keywordtype}{void} set\_f\_refcount(ArrayRefCountT \&refF) \{    }
\DoxyCodeLine{169     m\_ref\_F = refF;}
\DoxyCodeLine{170   \}}
\DoxyCodeLine{171   }
\DoxyCodeLine{172   \textcolor{comment}{// -\/1 is before the first grid point}}
\DoxyCodeLine{173   \textcolor{comment}{// N-\/1 (where grid.size() == N) is after the last grid point}}
\DoxyCodeLine{174   \textcolor{keywordtype}{int} find\_cell(\textcolor{keywordtype}{int} dim, T x)\textcolor{keyword}{ const }\{  }
\DoxyCodeLine{175     grid\_type \textcolor{keyword}{const} \&grid(m\_grid\_list[dim]);}
\DoxyCodeLine{176     \textcolor{keywordflow}{if} (x < *(grid.begin())) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{177     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x >= *(grid.end()-\/1)) \textcolor{keywordflow}{return} grid.size()-\/1;}
\DoxyCodeLine{178     \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{179       \textcolor{keyword}{auto} i\_upper = std::upper\_bound(grid.begin(), grid.end(), x);}
\DoxyCodeLine{180       \textcolor{keywordflow}{return} i\_upper -\/ grid.begin() -\/ 1;}
\DoxyCodeLine{181     \}   }
\DoxyCodeLine{182   \}}
\DoxyCodeLine{183   }
\DoxyCodeLine{184   \textcolor{comment}{// return the value of f at the given cell and vertex}}
\DoxyCodeLine{185   T get\_f\_val(array<int,N> \textcolor{keyword}{const} \&cell\_index, array<int,N> \textcolor{keyword}{const} \&v\_index)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{186     array<int,N> f\_index;}
\DoxyCodeLine{187     }
\DoxyCodeLine{188     \textcolor{keywordflow}{if} (m\_bContinuous) \{      }
\DoxyCodeLine{189       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<N; i++) \{}
\DoxyCodeLine{190         \textcolor{keywordflow}{if} (cell\_index[i] < 0) \{}
\DoxyCodeLine{191           f\_index[i] = 0;         }
\DoxyCodeLine{192         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cell\_index[i] >= m\_grid\_list[i].size()-\/1) \{}
\DoxyCodeLine{193           f\_index[i] = m\_grid\_list[i].size()-\/1;       }
\DoxyCodeLine{194         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{195           f\_index[i] = cell\_index[i] + v\_index[i];        }
\DoxyCodeLine{196         \}}
\DoxyCodeLine{197       \}}
\DoxyCodeLine{198     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{199       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<N; i++) \{}
\DoxyCodeLine{200         \textcolor{keywordflow}{if} (cell\_index[i] < 0) \{}
\DoxyCodeLine{201           f\_index[i] = 0;}
\DoxyCodeLine{202         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cell\_index[i] >= m\_grid\_list[i].size()-\/1) \{}
\DoxyCodeLine{203           f\_index[i] = (2*m\_grid\_list[i].size())-\/1;}
\DoxyCodeLine{204         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{205           f\_index[i] = 1 + (2*cell\_index[i]) + v\_index[i];}
\DoxyCodeLine{206         \}}
\DoxyCodeLine{207       \}}
\DoxyCodeLine{208     \}}
\DoxyCodeLine{209     \textcolor{keywordflow}{return} (*m\_pF)(f\_index);}
\DoxyCodeLine{210   \}}
\DoxyCodeLine{211   }
\DoxyCodeLine{212   T get\_f\_val(array<int,N> \textcolor{keyword}{const} \&cell\_index, \textcolor{keywordtype}{int} v)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{213     array<int,N> v\_index;}
\DoxyCodeLine{214     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} dim=0; dim<N; dim++) \{}
\DoxyCodeLine{215       v\_index[dim] = (v >> (N-\/dim-\/1)) \& 1;                      \textcolor{comment}{// test if the i-\/th bit is set}}
\DoxyCodeLine{216     \}}
\DoxyCodeLine{217     \textcolor{keywordflow}{return} get\_f\_val(cell\_index, v\_index);}
\DoxyCodeLine{218   \} }
\DoxyCodeLine{219 \};}
\DoxyCodeLine{220 }
\DoxyCodeLine{221 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{class} T, \textcolor{keywordtype}{bool} CopyData = true, \textcolor{keywordtype}{bool} Continuous = true, \textcolor{keyword}{class} ArrayRefCountT = EmptyClass, \textcolor{keyword}{class} Gr\textcolor{keywordtype}{id}RefCountT = EmptyClass>}
\DoxyCodeLine{222 \textcolor{keyword}{class }\mbox{\hyperlink{class_interp_simplex}{InterpSimplex}} : \textcolor{keyword}{public} \mbox{\hyperlink{class_n_d_interpolator}{NDInterpolator}}<N,T,CopyData,Continuous,ArrayRefCountT,GridRefCountT> \{}
\DoxyCodeLine{223 \textcolor{keyword}{public}:}
\DoxyCodeLine{224   \textcolor{keyword}{typedef} \mbox{\hyperlink{class_n_d_interpolator}{NDInterpolator<N,T,CopyData,Continuous,ArrayRefCountT,GridRefCountT>}} \mbox{\hyperlink{class_n_d_interpolator}{super}};}
\DoxyCodeLine{225   }
\DoxyCodeLine{226   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2, \textcolor{keyword}{class} IterT3>  }
\DoxyCodeLine{227   \mbox{\hyperlink{class_interp_simplex}{InterpSimplex}}(IterT1 grids\_begin, IterT2 grids\_len\_begin, IterT3 f\_begin, IterT3 f\_end)}
\DoxyCodeLine{228     : \mbox{\hyperlink{class_n_d_interpolator}{super}}(grids\_begin, grids\_len\_begin, f\_begin, f\_end)}
\DoxyCodeLine{229   \{\}}
\DoxyCodeLine{230   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2, \textcolor{keyword}{class} IterT3, \textcolor{keyword}{class} RefCountIterT>  }
\DoxyCodeLine{231   \mbox{\hyperlink{class_interp_simplex}{InterpSimplex}}(IterT1 grids\_begin, IterT2 grids\_len\_begin, IterT3 f\_begin, IterT3 f\_end, ArrayRefCountT \&refF, RefCountIterT ref\_begins)}
\DoxyCodeLine{232     : \mbox{\hyperlink{class_n_d_interpolator}{super}}(grids\_begin, grids\_len\_begin, f\_begin, f\_end, refF, ref\_begins)}
\DoxyCodeLine{233   \{\}}
\DoxyCodeLine{234 }
\DoxyCodeLine{235   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT>}
\DoxyCodeLine{236   T interp(IterT x\_begin)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{237     array<T,1> result;}
\DoxyCodeLine{238     array< array<T,1>, N > coord\_iter;}
\DoxyCodeLine{239     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<N; i++) \{}
\DoxyCodeLine{240       coord\_iter[i][0] = x\_begin[i];}
\DoxyCodeLine{241     \}}
\DoxyCodeLine{242     interp\_vec(1, coord\_iter.begin(), coord\_iter.end(), result.begin());}
\DoxyCodeLine{243     \textcolor{keywordflow}{return} result[0];}
\DoxyCodeLine{244   \}}
\DoxyCodeLine{245   }
\DoxyCodeLine{246   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2>}
\DoxyCodeLine{247   \textcolor{keywordtype}{void} interp\_vec(\textcolor{keywordtype}{int} n, IterT1 coord\_iter\_begin, IterT1 coord\_iter\_end, IterT2 i\_result)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{248     assert(N == coord\_iter\_end -\/ coord\_iter\_begin);}
\DoxyCodeLine{249     }
\DoxyCodeLine{250     array<int,N> cell\_index, v\_index;}
\DoxyCodeLine{251     array<std::pair<T, int>,N> xipair;  }
\DoxyCodeLine{252     \textcolor{keywordtype}{int} c;}
\DoxyCodeLine{253     T y, v0, v1;}
\DoxyCodeLine{254     \textcolor{comment}{//mexPrintf("{}\%d\(\backslash\)n"{}, n);}}
\DoxyCodeLine{255     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<n; i++) \{           \textcolor{comment}{// for each point}}
\DoxyCodeLine{256       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} dim=0; dim<N; dim++) \{}
\DoxyCodeLine{257         \textcolor{keyword}{typename} super::grid\_type \textcolor{keyword}{const} \&grid(super::m\_grid\_list[dim]);}
\DoxyCodeLine{258         c = this-\/>find\_cell(dim, coord\_iter\_begin[dim][i]);}
\DoxyCodeLine{259         \textcolor{comment}{//mexPrintf("{}\%d\(\backslash\)n"{}, c);}}
\DoxyCodeLine{260         \textcolor{keywordflow}{if} (c == -\/1) \{                  \textcolor{comment}{// before first grid point}}
\DoxyCodeLine{261           y = 1.0;}
\DoxyCodeLine{262         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c == grid.size()-\/1) \{    \textcolor{comment}{// after last grid point}}
\DoxyCodeLine{263           y = 0.0;}
\DoxyCodeLine{264         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{265           \textcolor{comment}{//mexPrintf("{}\%f \%f\(\backslash\)n"{}, grid[c], grid[c+1]);}}
\DoxyCodeLine{266           y = (coord\_iter\_begin[dim][i] -\/ grid[c]) / (grid[c + 1] -\/ grid[c]);}
\DoxyCodeLine{267           \textcolor{keywordflow}{if} (y < 0.0) y=0.0;}
\DoxyCodeLine{268           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (y > 1.0) y=1.0;}
\DoxyCodeLine{269         \}}
\DoxyCodeLine{270         xipair[dim].first = y;}
\DoxyCodeLine{271         xipair[dim].second = dim;       }
\DoxyCodeLine{272         cell\_index[dim] = c;}
\DoxyCodeLine{273       \}       }
\DoxyCodeLine{274       \textcolor{comment}{// sort xi's and get the permutation    }}
\DoxyCodeLine{275       std::sort(xipair.begin(), xipair.end(), [](std::pair<T, int> \textcolor{keyword}{const} \&a, std::pair<T, int> \textcolor{keyword}{const} \&b) \{}
\DoxyCodeLine{276         return (a.first < b.first);}
\DoxyCodeLine{277       \});}
\DoxyCodeLine{278       \textcolor{comment}{// walk the vertices of the simplex determined by the permutation  }}
\DoxyCodeLine{279       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<N; j++) \{}
\DoxyCodeLine{280         v\_index[j] = 1;}
\DoxyCodeLine{281       \}           }
\DoxyCodeLine{282       v0 = this-\/>get\_f\_val(cell\_index, v\_index);}
\DoxyCodeLine{283       y = v0;}
\DoxyCodeLine{284       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<N; j++) \{}
\DoxyCodeLine{285         v\_index[xipair[j].second]-\/-\/;        }
\DoxyCodeLine{286         v1 = this-\/>get\_f\_val(cell\_index, v\_index);}
\DoxyCodeLine{287         y += (1.0 -\/ xipair[j].first) * (v1-\/v0);     \textcolor{comment}{// interpolate}}
\DoxyCodeLine{288         v0 = v1;}
\DoxyCodeLine{289       \}}
\DoxyCodeLine{290       *i\_result++ = y;}
\DoxyCodeLine{291     \}    }
\DoxyCodeLine{292   \}  }
\DoxyCodeLine{293 \};}
\DoxyCodeLine{294 }
\DoxyCodeLine{295 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{class} T, \textcolor{keywordtype}{bool} CopyData = true, \textcolor{keywordtype}{bool} Continuous = true, \textcolor{keyword}{class} ArrayRefCountT = EmptyClass, \textcolor{keyword}{class} Gr\textcolor{keywordtype}{id}RefCountT = EmptyClass>}
\DoxyCodeLine{296 \textcolor{keyword}{class }\mbox{\hyperlink{class_interp_multilinear}{InterpMultilinear}} : \textcolor{keyword}{public} \mbox{\hyperlink{class_n_d_interpolator}{NDInterpolator}}<N,T,CopyData,Continuous,ArrayRefCountT,GridRefCountT> \{}
\DoxyCodeLine{297 \textcolor{keyword}{public}:}
\DoxyCodeLine{298   \textcolor{keyword}{typedef} \mbox{\hyperlink{class_n_d_interpolator}{NDInterpolator<N,T,CopyData,Continuous,ArrayRefCountT,GridRefCountT>}} \mbox{\hyperlink{class_n_d_interpolator}{super}};}
\DoxyCodeLine{299   }
\DoxyCodeLine{300   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2, \textcolor{keyword}{class} IterT3>  }
\DoxyCodeLine{301   \mbox{\hyperlink{class_interp_multilinear}{InterpMultilinear}}(IterT1 grids\_begin, IterT2 grids\_len\_begin, IterT3 f\_begin, IterT3 f\_end)}
\DoxyCodeLine{302     : \mbox{\hyperlink{class_n_d_interpolator}{super}}(grids\_begin, grids\_len\_begin, f\_begin, f\_end)}
\DoxyCodeLine{303   \{\}}
\DoxyCodeLine{304   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2, \textcolor{keyword}{class} IterT3, \textcolor{keyword}{class} RefCountIterT>  }
\DoxyCodeLine{305   \mbox{\hyperlink{class_interp_multilinear}{InterpMultilinear}}(IterT1 grids\_begin, IterT2 grids\_len\_begin, IterT3 f\_begin, IterT3 f\_end, ArrayRefCountT \&refF, RefCountIterT ref\_begins)}
\DoxyCodeLine{306     : \mbox{\hyperlink{class_n_d_interpolator}{super}}(grids\_begin, grids\_len\_begin, f\_begin, f\_end, refF, ref\_begins)}
\DoxyCodeLine{307   \{\}}
\DoxyCodeLine{308 }
\DoxyCodeLine{309   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2>}
\DoxyCodeLine{310   \textcolor{keyword}{static} T linterp\_nd\_unitcube(IterT1 f\_begin, IterT1 f\_end, IterT2 xi\_begin, IterT2 xi\_end) \{}
\DoxyCodeLine{311     \textcolor{keywordtype}{int} n = xi\_end -\/ xi\_begin;}
\DoxyCodeLine{312     \textcolor{keywordtype}{int} f\_len = f\_end -\/ f\_begin;}
\DoxyCodeLine{313     assert(1 << n == f\_len);}
\DoxyCodeLine{314     T sub\_lower, sub\_upper;}
\DoxyCodeLine{315     \textcolor{keywordflow}{if} (n == 1) \{}
\DoxyCodeLine{316       sub\_lower = f\_begin[0];}
\DoxyCodeLine{317       sub\_upper = f\_begin[1];}
\DoxyCodeLine{318     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{319       sub\_lower = linterp\_nd\_unitcube(f\_begin, f\_begin + (f\_len/2), xi\_begin + 1, xi\_end);}
\DoxyCodeLine{320       sub\_upper = linterp\_nd\_unitcube(f\_begin + (f\_len/2), f\_end, xi\_begin + 1, xi\_end);}
\DoxyCodeLine{321     \}  }
\DoxyCodeLine{322     T result = sub\_lower + (*xi\_begin)*(sub\_upper -\/ sub\_lower);}
\DoxyCodeLine{323     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{324   \}}
\DoxyCodeLine{325 }
\DoxyCodeLine{326   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT>}
\DoxyCodeLine{327   T interp(IterT x\_begin)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{328     array<T,1> result;}
\DoxyCodeLine{329     array< array<T,1>, N > coord\_iter;}
\DoxyCodeLine{330     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<N; i++) \{}
\DoxyCodeLine{331       coord\_iter[i][0] = x\_begin[i];}
\DoxyCodeLine{332     \}}
\DoxyCodeLine{333     interp\_vec(1, coord\_iter.begin(), coord\_iter.end(), result.begin());}
\DoxyCodeLine{334     \textcolor{keywordflow}{return} result[0];}
\DoxyCodeLine{335   \}}
\DoxyCodeLine{336   }
\DoxyCodeLine{337   \textcolor{keyword}{template} <\textcolor{keyword}{class} IterT1, \textcolor{keyword}{class} IterT2>}
\DoxyCodeLine{338   \textcolor{keywordtype}{void} interp\_vec(\textcolor{keywordtype}{int} n, IterT1 coord\_iter\_begin, IterT1 coord\_iter\_end, IterT2 i\_result)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{339     assert(N == coord\_iter\_end -\/ coord\_iter\_begin);}
\DoxyCodeLine{340     array<int,N> index;}
\DoxyCodeLine{341     \textcolor{keywordtype}{int} c;}
\DoxyCodeLine{342     T y, xi;}
\DoxyCodeLine{343     vector<T> f(1 << N);}
\DoxyCodeLine{344     array<T,N> x;}
\DoxyCodeLine{345     }
\DoxyCodeLine{346     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<n; i++) \{                               \textcolor{comment}{// loop over each point}}
\DoxyCodeLine{347       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} dim=0; dim<N; dim++) \{                       \textcolor{comment}{// loop over each dimension}}
\DoxyCodeLine{348         \textcolor{keyword}{auto} \textcolor{keyword}{const} \&grid(super::m\_grid\_list[dim]);      }
\DoxyCodeLine{349         xi = coord\_iter\_begin[dim][i];}
\DoxyCodeLine{350         c = this-\/>find\_cell(dim, coord\_iter\_begin[dim][i]);}
\DoxyCodeLine{351         \textcolor{keywordflow}{if} (c == -\/1) \{                  \textcolor{comment}{// before first grid point}}
\DoxyCodeLine{352           y = 1.0;}
\DoxyCodeLine{353         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c == grid.size()-\/1) \{    \textcolor{comment}{// after last grid point}}
\DoxyCodeLine{354           y = 0.0;}
\DoxyCodeLine{355         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{356           y = (coord\_iter\_begin[dim][i] -\/ grid[c]) / (grid[c + 1] -\/ grid[c]);}
\DoxyCodeLine{357           \textcolor{keywordflow}{if} (y < 0.0) y=0.0;}
\DoxyCodeLine{358           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (y > 1.0) y=1.0;}
\DoxyCodeLine{359         \}}
\DoxyCodeLine{360         index[dim] = c;}
\DoxyCodeLine{361         x[dim] = y;}
\DoxyCodeLine{362       \}}
\DoxyCodeLine{363       \textcolor{comment}{// copy f values at vertices}}
\DoxyCodeLine{364       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} v=0; v < (1 << N); v++) \{                    \textcolor{comment}{// loop over each vertex of hypercube}}
\DoxyCodeLine{365         f[v] = this-\/>get\_f\_val(index, v);}
\DoxyCodeLine{366       \}}
\DoxyCodeLine{367       *i\_result++ = linterp\_nd\_unitcube(f.begin(), f.end(), x.begin(), x.end());}
\DoxyCodeLine{368     \}}
\DoxyCodeLine{369   \}}
\DoxyCodeLine{370 \};  }
\DoxyCodeLine{371 }
\DoxyCodeLine{372 \textcolor{keyword}{typedef} \mbox{\hyperlink{class_interp_simplex}{InterpSimplex<1,double>}} \mbox{\hyperlink{class_interp_simplex}{NDInterpolator\_1\_S}};}
\DoxyCodeLine{373 \textcolor{keyword}{typedef} \mbox{\hyperlink{class_interp_simplex}{InterpSimplex<2,double>}} \mbox{\hyperlink{class_interp_simplex}{NDInterpolator\_2\_S}};}
\DoxyCodeLine{374 \textcolor{keyword}{typedef} \mbox{\hyperlink{class_interp_simplex}{InterpSimplex<3,double>}} \mbox{\hyperlink{class_interp_simplex}{NDInterpolator\_3\_S}};}
\DoxyCodeLine{375 \textcolor{keyword}{typedef} \mbox{\hyperlink{class_interp_simplex}{InterpSimplex<4,double>}} \mbox{\hyperlink{class_interp_simplex}{NDInterpolator\_4\_S}};}
\DoxyCodeLine{376 \textcolor{keyword}{typedef} \mbox{\hyperlink{class_interp_simplex}{InterpSimplex<5,double>}} \mbox{\hyperlink{class_interp_simplex}{NDInterpolator\_5\_S}};}
\DoxyCodeLine{377 \textcolor{keyword}{typedef} \mbox{\hyperlink{class_interp_multilinear}{InterpMultilinear<1,double>}} \mbox{\hyperlink{class_interp_multilinear}{NDInterpolator\_1\_ML}};}
\DoxyCodeLine{378 \textcolor{keyword}{typedef} \mbox{\hyperlink{class_interp_multilinear}{InterpMultilinear<2,double>}} \mbox{\hyperlink{class_interp_multilinear}{NDInterpolator\_2\_ML}};}
\DoxyCodeLine{379 \textcolor{keyword}{typedef} \mbox{\hyperlink{class_interp_multilinear}{InterpMultilinear<3,double>}} \mbox{\hyperlink{class_interp_multilinear}{NDInterpolator\_3\_ML}};}
\DoxyCodeLine{380 \textcolor{keyword}{typedef} \mbox{\hyperlink{class_interp_multilinear}{InterpMultilinear<4,double>}} \mbox{\hyperlink{class_interp_multilinear}{NDInterpolator\_4\_ML}};}
\DoxyCodeLine{381 \textcolor{keyword}{typedef} \mbox{\hyperlink{class_interp_multilinear}{InterpMultilinear<5,double>}} \mbox{\hyperlink{class_interp_multilinear}{NDInterpolator\_5\_ML}};}
\DoxyCodeLine{382 }
\DoxyCodeLine{383 \textcolor{comment}{// C interface}}
\DoxyCodeLine{384 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \{}
\DoxyCodeLine{385   \textcolor{keywordtype}{void} linterp\_simplex\_1(\textcolor{keywordtype}{double} **grids\_begin, \textcolor{keywordtype}{int} *grid\_len\_begin, \textcolor{keywordtype}{double} *pF, \textcolor{keywordtype}{int} xi\_len, \textcolor{keywordtype}{double} **xi\_begin, \textcolor{keywordtype}{double} *pResult);}
\DoxyCodeLine{386   \textcolor{keywordtype}{void} linterp\_simplex\_2(\textcolor{keywordtype}{double} **grids\_begin, \textcolor{keywordtype}{int} *grid\_len\_begin, \textcolor{keywordtype}{double} *pF, \textcolor{keywordtype}{int} xi\_len, \textcolor{keywordtype}{double} **xi\_begin, \textcolor{keywordtype}{double} *pResult);}
\DoxyCodeLine{387   \textcolor{keywordtype}{void} linterp\_simplex\_3(\textcolor{keywordtype}{double} **grids\_begin, \textcolor{keywordtype}{int} *grid\_len\_begin, \textcolor{keywordtype}{double} *pF, \textcolor{keywordtype}{int} xi\_len, \textcolor{keywordtype}{double} **xi\_begin, \textcolor{keywordtype}{double} *pResult);  }
\DoxyCodeLine{388 \}}
\DoxyCodeLine{389 }
\DoxyCodeLine{390 \textcolor{keywordtype}{void} \textcolor{keyword}{inline} linterp\_simplex\_1(\textcolor{keywordtype}{double} **grids\_begin, \textcolor{keywordtype}{int} *grid\_len\_begin, \textcolor{keywordtype}{double} *pF, \textcolor{keywordtype}{int} xi\_len, \textcolor{keywordtype}{double} **xi\_begin, \textcolor{keywordtype}{double} *pResult) \{}
\DoxyCodeLine{391   \textcolor{keyword}{const} \textcolor{keywordtype}{int} N=1;}
\DoxyCodeLine{392   \textcolor{keywordtype}{size\_t} total\_size = 1;  }
\DoxyCodeLine{393   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<N; i++)   \{     }
\DoxyCodeLine{394     total\_size *= grid\_len\_begin[i];}
\DoxyCodeLine{395   \}      }
\DoxyCodeLine{396   \mbox{\hyperlink{class_interp_simplex}{InterpSimplex<N, double, false>}} interp\_obj(grids\_begin, grid\_len\_begin, pF, pF + total\_size);}
\DoxyCodeLine{397   interp\_obj.interp\_vec(xi\_len, xi\_begin, xi\_begin + N, pResult);}
\DoxyCodeLine{398 \}}
\DoxyCodeLine{399 }
\DoxyCodeLine{400 \textcolor{keywordtype}{void} \textcolor{keyword}{inline} linterp\_simplex\_2(\textcolor{keywordtype}{double} **grids\_begin, \textcolor{keywordtype}{int} *grid\_len\_begin, \textcolor{keywordtype}{double} *pF, \textcolor{keywordtype}{int} xi\_len, \textcolor{keywordtype}{double} **xi\_begin, \textcolor{keywordtype}{double} *pResult) \{}
\DoxyCodeLine{401   \textcolor{keyword}{const} \textcolor{keywordtype}{int} N=2;}
\DoxyCodeLine{402   \textcolor{keywordtype}{size\_t} total\_size = 1;  }
\DoxyCodeLine{403   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<N; i++)   \{     }
\DoxyCodeLine{404     total\_size *= grid\_len\_begin[i];}
\DoxyCodeLine{405   \}      }
\DoxyCodeLine{406   \mbox{\hyperlink{class_interp_simplex}{InterpSimplex<N, double, false>}} interp\_obj(grids\_begin, grid\_len\_begin, pF, pF + total\_size);}
\DoxyCodeLine{407   interp\_obj.interp\_vec(xi\_len, xi\_begin, xi\_begin + N, pResult);}
\DoxyCodeLine{408 \}}
\DoxyCodeLine{409 }
\DoxyCodeLine{410 \textcolor{keywordtype}{void} \textcolor{keyword}{inline} linterp\_simplex\_3(\textcolor{keywordtype}{double} **grids\_begin, \textcolor{keywordtype}{int} *grid\_len\_begin, \textcolor{keywordtype}{double} *pF, \textcolor{keywordtype}{int} xi\_len, \textcolor{keywordtype}{double} **xi\_begin, \textcolor{keywordtype}{double} *pResult) \{}
\DoxyCodeLine{411   \textcolor{keyword}{const} \textcolor{keywordtype}{int} N=3;}
\DoxyCodeLine{412   \textcolor{keywordtype}{size\_t} total\_size = 1;  }
\DoxyCodeLine{413   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<N; i++)   \{     }
\DoxyCodeLine{414     total\_size *= grid\_len\_begin[i];}
\DoxyCodeLine{415   \}      }
\DoxyCodeLine{416   \mbox{\hyperlink{class_interp_simplex}{InterpSimplex<N, double, false>}} interp\_obj(grids\_begin, grid\_len\_begin, pF, pF + total\_size);}
\DoxyCodeLine{417   interp\_obj.interp\_vec(xi\_len, xi\_begin, xi\_begin + N, pResult);}
\DoxyCodeLine{418 \}}
\DoxyCodeLine{419 }
\DoxyCodeLine{420 }
\DoxyCodeLine{421 }
\DoxyCodeLine{422 }
\DoxyCodeLine{423 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//\_linterp\_h}}

\end{DoxyCode}
